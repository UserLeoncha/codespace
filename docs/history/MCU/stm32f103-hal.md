# stm32f103-note

## 前期准备

### C语言基础知识复习
#### 要点一：stdint.h简介
C99标准文件，在MDK5\ARM\ARMCC\include中，对每一个类型名都有清晰的定义。如果要MDK支持C99需要在编辑器中勾选C99选项。
作用：统一类型别名。
#### 要点二：位操作
|运算符|含义|举例|
|---|---|---|
|&|按位与|0&0=0<br>1&0=0<br>0&1=0<br>1&1=1|
|&#124;|按位或|0&#124;0=0<br>1&#124;0=1<br>0&#124;1=1<br>1&#124;1=1|
|^|按位异或|0^0=0<br>1^0=1<br>0^1=1<br>1^1=0|
|~|按位取反|~11100010=00011101|
|<<|左移|11100010<<2=10001000|
|>>|右移|11100010>>2=00111000|

作用：可以用来给寄存器赋值
```c
//32位寄存器
uint32_t temp = 0;
//方法一
temp &= 0xFFFFFFBF;
temp |= 0x00000040;
//方法二
temp &= ~(1<<6);
temp |= 1<<6;
//按位异或用于控制位6翻转
temp ^= 1<<6;
```
#### 要点三：宏定义
提高效率、可读性、易改性、核心是替换
```c
#define mynumber 123456
#define PI  3.14159
#define HSE_VALUE   8000000U//高速外部晶振
```
mynumber    标识符:宏定义的名字
123456      字符串：常数、表达式、格式串等

宏定义展开在预编译阶段

```c
#define LED(x) do{x ?
    HAL_GPIO_WritePin(LED1_GPIO_PORT, LED1_GPIO_PIN, GPIO_PIN_SET):
    HAL_GPIO_WritePin(LED1_GPIO_PORT, LED1_GPIO_PIN, GPIO_PIN_RESET);
}while(0)
```
#### 要点四：条件编译
让编译器只对满足条件的代码进行编译，不满足条件的不参与编译！
|指令|作用|
|---|---|
|#if|编译预处理条件指令，类似if|
|#ifdef|判断某个宏是否已被定义|
|#ifndef|判断某个宏是否未被定义|
|#elif|若前面的条件不满足，则判断新的条件，类似else if|
|#else|若前面的条件不满足，则执行后面的语句，类似else|
|#endif|#if，#ifdef，#ifndef的结束标志|
```c
//头文件的条件编译
#ifdef _LED_H
#define _LED_H
#include "./SYSTEM/sys/sys.h"
code
#endif

//代码条件编译
#if SYS_SUPPORT_OS
    code
#endif
```
#### 要点五：extern声明
放到函数/变量前，表示此函数/变量在其他文件定义，以便本文件引用
```c
extern uint_16_t g_usart_rx_sta;
extern void delay_us(uint32_t nus);
```
#### 要点六：代码规范
《嵌入式单片机C代码规范与风格.pdf》

1.所有函数/变量名字非特殊情况，一般使用小写字母
2.注释风格使用doxgen风格，除屏蔽外，一律使用/**/方式进行注释；
3.TAB键使用4个空格对齐，不使用默认的方式进行对齐；
4.每两个函数之间，有且仅有1个空行；
5.相对独立的程序块之间，使用一个空行隔开；
6.全局变量命名一般用g_开头，全局指针命名一般用p_开头；
7.if、for、while、do、case、switch、deafult等语句单独占一行，一般无论有多少执行语句，都要用加括号：{}。

#### 类型别名（typedef）
为现有的数据类型创建一个新名字，或称为类型别名，用来简化变量的定义
```c
typedef 现有类型 新名字

typedef unsigned char   uint8_t;
typedef unsigned short int  uint16_t;
typedef unsigned int    uint32_t;

Struct GPIO_TypeDef {
    __IO uint32_t CRL;
    __IO uint32_t CRH;
};
Struct GPIO_TypeDef gpiox;

typedef struct {
    __IO uint32_t CRL;
    __IO uint32_t CRH;
}GPIO_TypeDef;
GPIOTypeDef gpiox;
```
#### 结构体
有若干基本数据类型集合组成的一种自定义数据类型，也叫聚合类型
```c
strut 结构体名 {
    成员列表；
}变量名列表（可选）

struct student {
    char    *name;  /*姓名*/
    int     num;    /*学号*/
}stu1, stu2;

//类型别名应用
typedef struct {
    uint32_t    Pin;    //引脚
    uint32_t    Mode;   //工作模式
    uint32_t    Pull;   //上下拉
    uint32_t    Speed;  //IO速度
}GPIO_InitTypeDef;
```
#### 指针
指针就是内存的地址
指针变量是保存了指针的变量
```c
类型名 *指针变量名
char *p_str = "This is a test!";
*p_str;//取p_str变量的值
&p_str;
```
##### 指针两大常见问题
1.未分配（申请）内存就使用<br>
2.越界使用

## 内核与芯片
### STM32系统架构
#### Cortex M内核 & 芯片
内核与外设时间通过内部总线连接，MCU厂商经ARM公司授权，添加不同的外设 = 各种XX32芯片

浏览芯片资料
#### F1系统架构
4个主动单元+4个被动单元
|主动单元|被动单元|
|---|---|
|Cortex M3内核 DCode总线（D-Bus）|内部FLASH|
|Cortex M3内核 系统总线（S-Bus）|内部SRAM|
|通用DMA1|FSMC|
|通用DMA2|AHB到APB的桥，它链接的所有APB外设|
AHB：高级高性能总线<br>
APB：高级外围总线

ICode总线直接连接Flash接口，不需要经过总线矩阵。<br>
AHB最高频率为72MHz，APB1最高频率为36MHz，APB2最高频率为72MHz<br>

在互联型的产品中有5个主动单元，3个被动单元
### STM32的寻址范围
1.STM32是32位单片机，有32根地址线，每根地址线有两种状态：导通或不导通，寻址范围为$2^{32}$，即为4G（字节）。

2.单片机内存地址访问的存储单元是按字节编址的（而不是bit）

3.STM32寻址范围：0x0000 0000 ~ 0x FFFF FFFF
### 存储器映射
存储器指可以存储数据的设备，本身没有地址信息，对存储器分配地址的过程称为存储器映射。<br>
attention:存储器没有地址信息

19根地址线：A0-A18  512K个地址<br>
16根数据线：D0-D15  2个字节<br>
这个芯片的容量为512K * 2个字节 = 1024K

地址范围：0-512K<br>
映射1：0-512K<br>
映射2：1-512K+1<br>
映射3：100K-612K<br>
映射4：512K-1024K

存储器功能划分<br>
ST将4GB$2^{32}$的地址空间分成8个块

|存储块|功能|地址范围|
|---|---|---|
|Block0|Code(FLASH)|0x0000 0000 ~ 0x1FFF FFFF(512MB)|
|Block1|SRAM|0x2000 0000~ 0x3FFF FFFF(512MB)|
|Block2|片上外设|0x4000 0000 ~ 0x5FFF FFFF(512MB)|
|Block3|FSMC Bank1&2|0x6000 0000 ~ 0x7FFF FFFF(512MB)|
|Block4|FSMC Bank3&4|0x8000 0000 ~ 0x9FFF FFFF(512MB)|
|Block5|FSMC寄存器|0xA000 0000 ~ 0xBFFF FFFF(512MB)|
|Block6|没用到|0xC000 0000 ~ 0xDFFF FFFF(512MB)|
|Block7|Cortex M3内部外设|0xE000 0000 ~ 0xFFFF FFFF(512MB)|

侧重点在前面三个块中。

FSMC Bank是什么

#### Block0（FLASH）功能划分
|功能|地址范围|
|---|---|
|FLASH或系统存储器别名区|0x0000 0000 ~ 0x0007 FFFF(512KB)|
|保留|0x0008 0000 ~ 0x07FF FFFF|
|用户FLASH，用于存储用户代码|0x0800 0000 ~ 0x0807 FFFF(512KB)|
|保留|0x0808 0000 ~ 0x1FFF EFFF|
|系统存储器，存储出厂bootloader|0x1FFF F000 ~ 0x1FFF F7FF(2KB)|
|选项字节，配置读保护等|0x1FFF F800 ~ 0x1FFF F80F(16B)|
|保留|0x1FFF F810 ~ 0x1FFF FFFF|

用户代码只有512KB的空间
#### Block1(SRAM)功能划分
|功能|地址范围|
|---|---|
|SRAM|0x2000 0000 ~ 0x2000 FFFF(64KB)|
|保留|0x2001 0000 ~ 0x3FFF FFFF|
#### Block2(外设)功能划分
|功能|地址范围|
|---|---|
|APB1总线外设|0x4000 0000 ~ 0x4000 77FF|
|保留|0x4000 7800 ~ 0x4000 FFFF|
|APB2总线外设|0x4001 0000 ~ 0x4000 3FFF|
|保留|0x4001 4000 ~ 0x4001 7FFF|
|AHB总线外设|0x4001 8000 ~ 0x4002 33FF|
|保留|0x4002 3400 ~ 0x5FFF FFFF|
参考开发指南5.3.3 
### 寄存器映射
寄存器是单片机内部一种特殊的内存，可以实现对单片机各个功能的控制，简单来说：寄存器是单片机内部的控制机构

寄存器分类：
<table>
    <tr>
        <td>大类</td>
        <td>小类</td>
        <td>说明</td>
    </tr>
    <tr>
        <td rowspan="5">内核寄存器</td>
        <td>内核相关寄存器</td>
        <td>包括R0-R15、xPSR、特殊功能寄存器等</td>
    </tr>
    <tr>
        <td>中断控制寄存器</td>
        <td>包括NVIC和SCB相关寄存器，NVIC有：ISER、ICER、ISPR、IP等；SCB有：VTOR、AIRCR、SCR等</td>
    </tr>
    <tr>
        <td>SysTick寄存器</td>
        <td>包含CTRL、LOAD、VAL和CALIB四个寄存器</td>
    </tr>
    <tr>
        <td>内存保护寄存器</td>
        <td>可选功能，STM32F103没有</td>
    </tr>
    <tr>
        <td>调试系统寄存器</td>
        <td>ETM、ITM、DWT、IPIU等相关寄存器</td>
    </tr>
    <tr>
        <td>外设寄存器</td>
        <td></td>
        <td>包含GPIO、UART、IIC、SPI、TIM、DMA、ADC、DAC、RTC、I/WWDG、PWR、CAN、USB等各种外设寄存器</td>
    </tr>
</table>

#### 寄存器映射（F1）
寄存器是特殊的存储器，给寄存器地址命名的过程，就叫寄存器映射

寄存器名字
偏移量与复位量
寄存器位表
位功能描述

地址偏移
复位值


```c
//直接操作寄存器地址
*(unsigned int *)(0x4001080C) = 0xFFFF;

//定义一个名字后再操作
#define GPIOA_ODR   *(undigned int *)(0x4001080C)
GPIOA_ODR = 0XFFFF;
```
#### 寄存器地址计算
为了方便编写代码及使用，我们将寄存器地址分为三个部分:<br>
1、总线基地址(BUS_BASE_ADDR)<br>
2、外设基于总线基地址的偏移量(PERIPH_OFFSET)<br>
3、寄存器相对于外设基地址的偏移量(REG_OFFSET)<br>
寄存器地址 = BUS_BASE_ADDR + PERIPH_OFFSET + REG_OFFSET

总线基地址
|总线|基地址|偏移量|
|---|---|---|
|APB1|0x4000 0000|0|
|APB2|0x4001 0000|0x1 0000|
|AHB|0x4001 8000|0x1 8000|

APB1总线的基地址，也叫外设基地址(PERIPH_BASE)
此表的偏移量：是相对外设基地址(PERIPH_BASE)来说的

<table>
    <tr>
        <td>所属总线</td>
        <td>外设</td>
        <td>基地址</td>
        <td>偏移量</td>
    </tr>
    <tr>
        <td rowspan="7">APB2 0x4001 0000</td>
        <td>GPIOA</td>
        <td>0x4001 0800</td>
        <td>0x800</td>
    </tr>
    <tr>
        <td>GPIOB</td>
        <td>0x4001 0C00</td>
        <td>0xC00</td>
    </tr>
    <tr>
        <td>GPIOC</td>
        <td>0x4001 1000</td>
        <td>1000</td>
    </tr>
    <tr>
        <td>GPIOD</td>
        <td>0x4001 1400</td>
        <td>1400</td>
    </tr>
    <tr>
        <td>GPIOE</td>
        <td>0x4001 1800</td>
        <td>1800</td>
    </tr>
    <tr>
        <td>GPIOF</td>
        <td>0x4001 1C00</td>
        <td>1C00</td>
    </tr>
    <tr>
        <td>GPIOG</td>
        <td>0x4001 2000</td>
        <td>2000</td>
    </tr>
</table>
此表的偏移量：是相对APB2外设基地址(APB2PERIPH_BASE)来说的




### STM32系统框架

#### Cortex M 内核&芯片
Cortex-M3/M4/M7内核

## 中断 NVIC与EXIT

### 什么是中断？
打断CPU执行正常的程序，转而处理紧急程序，然后返回原暂停的程序继续运行，就叫中断 。
#### 中断的作用和意义

#### 1.实时控制
在确定的时间内对相应事件作出响应，如：温度控制
#### 2.故障传输
检测到故障，需要第一时间处理、如：电梯门夹人了
#### 3.数据传输
不确定数据何时回来，如：串口数据接收

### 中断的意义
高效处理紧急程序，不会一直占用CPU资源

### STM32 GPIO外部中断处理
GPIO三种输入 -> AFIO（F1）/SYSCFG（F4/F7/H7） -> EXTI -> NVIC 使能、优先级控制 -> 处理中断

### NVIC
 
### 基本概念
Nested vectored interrupt controller,嵌入式向量中断控制器，属于内核(M3/4/7)
NVIC支持：256个中断（16 core 240EXTI），支持256个优先级，允许裁剪
|STM32型号|内核中断|外部中断|中断优先级|
|---- |----|-------|------|
|STM32F103|10|60|16|
|STM32F407|10|82|16|
|STM32F429|10|91|16|
|STM32F750|10|98|16|
|STM32F767|10|110|16|
|STM32H743|10|150|16|
|STM32H750|10|150|16|

### 什么是中断向量表
定义一块固定的内存，以4byte对齐，存放各个中断服务函数程序的首地址
中断向量表定义在启动文件，当发生中断，CPU会自动执行对应的中断服务函数。
正常情况下CPU会被main函数占用
Reset_Handler、NMI_Handler、HardFault_Handler等10个内核中断
会抢夺cpu使用权

在setup.s文件中有vector，其中DCD部分包括十个中断

### NVIC相关寄存器介绍
|  寄存器名称           | 位数 |寄存器个数|备注|
| ------               | ----------- |---|---|
| 中断使能寄存器（ISER） | 32  |8|每个位控制一个中断|
| 中断除能寄存器(ICER)  | 32  |8|每个位控制一个中断
| 应用程序中断及复位控制寄存器(AIRCR) |32|1|位[10:8]控制优先级分组|
| 中断优先级寄存器(IPR)  | 8|240|8个位对应一个中断，而STM32只使用高4位|

### 其他操作
中断挂起、解挂、激活标志等非常用功能

### NVIC工作原理
先通过中断使能寄存器与中断失能寄存器，1bit控制一个中断，然后通过IPR设置中断优先级，8bit控制一个中断优先级，AIRCR[10:8]控制8种分组;内核中断通过SHPR控制，不经过中断使能寄存器与中断失能寄存器处理。

### 中断优先级基本概念
1.抢占优先级（pre）：高抢占优先级可以打断正在执行的低抢占优先级中断
2.相应优先级（sub）：当抢占优先级相同时，相应优先级高的先执行，但是不能互相打断
3.抢占和响应都相同的情况下，自然优先级越高的，先执行
4.自然优先级：中断向量表的优先级
5.数值越小，表示优先级越高

### 中断优先级分组

|优先级分组|AIRCR[10:8]|IPRx bit[7:4]分配|分配结果|
|---|---|---|---|
|0|111|None:[7:4]|0位抢占优先级，4位响应优先级|
|1|110|[7]:[6:4]|1位抢占优先级，3位响应优先级|
|2|101|[7:6]:[5:4]|2位抢占优先级，2位响应优先级|
|3|100|[7:5]:[4]|3位抢占优先级，1位响应优先级|
|4|011|[7:4]:None|4位抢占优先级，0位响应优先级|

### NVIC的使用

1.设置中断分组 AIRCR[10:8],HAL_NVIC_SetPriorityGrouping

2.设置中断优先级 IPRx bit[7:4], HAL_NVIC_SetPriority

3.使能中断 ISERx, HAL_NVIC_EnableIRQ

中断分组在HAL_Init()函数中设置

### EXTI



### EXTI和IO的映射关系

### 如何使用中断

### 通用外设驱动模型（四步法）

### HAL库中断回调处理机制介绍


## 串口与通信
这是通信的起点
### 单片机中的数据通信

#### 串行与并行
|   |传输速率|抗干扰能力|通信距离|资源占用|成本|
|---|---|---|---|---|---|
|串行通信|较低|较强|较长|较少|较低|
|并行通信|较高|较弱|较短|较多|较高|

对比串行通信与并行通信，可以认为串行通信是一条工作效率很高的流水线，并行通信是很多条流水线同时工作。串行通信设备一次传输一个byte，通过快速重复这个步骤来提高传输速率；串行通过增加数据通道来增加传输效率，但是信息的传输速度没有提高

#### 单工/半双工/全双工通信
单工通信：数据只能沿一个方向传输

半双工通信：数据可以沿两个方向传输，但需要分时进行

全双工通信：数据可以同时进行双向传输

#### 同步/异步
按照同步与方式分类可以分为同步通信与异步通信
同步通信发送方与接收方共用同一时钟信号，异步通信没有时钟信号，通过在数据信号中加入起始位和停止位等一些同步信号
#### 波特率

bit率：每秒钟传送的比特数，单位bit/s

波特率：每秒钟传送的码元数，单位Baud

bit率=波特率*log2M，M表示每个码元承载的信息量

在二进制系统中，波特率树枝上等于比特率

#### 常见的串行通信接口
|通信接口|接口引脚|数据同步方式|数据传输方向|
|---|---|---|---|
|UART（通用异步收发器）|TXD：发送端<br>RXD：接收端<br>GND：公共地|异步通信|全双工|
|1-wire|DQ：发送/接受端|异步通信|半双工|
|IIC|SCL：同步时钟<br>SDA：数据输入/输出端|同步通信|半双工|
|SPI|SCK：同步时钟<br>MISO：主机输入，从机输出<br>MOSI：主机输出，从机输入<br>CS：片选信号|同步通信|全双工|
### 串口RS232

#### 什么是串口？
串行通信接口：指按位发送与接收的接口。如：RS-232/422/485等

RS-232接口（DB9）数据：<br>
TXD（pin 3）：串行数据输出<br>
RXD（pin 2）：串行数据输入

握手：<br>
RTS（pin 7）：请求发送<br>
CTS（pin 8）：清除发送<br>
DSR（pin 6）：数据发送就绪<br>
DCD（pin 1）：数据载波检测<br>
DTR（pin 4）：数据终端就绪

地线：GND（pin 5）：信号地<br>
其他：RI（pin 9）：振铃指示

#### RS-232电平与CMOS/TTL电平对比
||逻辑1|逻辑0|
|---|---|---|
|RS-232电平|-15V - -3V|+3V - +15V|
|CMOS电平|3.3V|0V|
|TTL电平|5V|0V|

##### 设备间通信
控制器A-》电平转换芯片-》DB9 《- RS-232电平 -》DB9-》电平转换芯片 -》控制器B<br>
电平转换芯片常用MAX3232或者SP3232等<br>
TXD与RXD必须交叉连接才能正常通信。

##### PC的USB接口与串口通信
PC（USB接口）《---》Type-c接口《---》USB/串口转换电路（CH340C）《---》开发板
#### RS-232异步通信协议
默认拉高，因此发送端需要使用上拉输出，拉低一个位长，保持低电平为启动位，下面八bit为数据位，可能有一位奇偶校验位，保持拉高一个位长。<br>
启动位：必须占1个位长，保持逻辑0电平<br>
有效数据位：可选5、6、7、8、9个位长，LSB在前，MSB在后<br>
校验位：可选占0.5，1，1.5，2个位长，保持逻辑1电平

### STM32的USART
通用同步异步收发器<br>
USART/UART都可以与外部设备进行全双工异步通信，USART我们常用的也是异步通信

#### 主要特征
1.全双工异步通信<br>
2.单线半双工通信<br>
3.单独的发送器和接收器使能位<br>
4.可配置使用DMA的多缓冲器通信<br>
5.多个带标志的中断源<br>
具体内容查看STM32参考手册
#### 如何查看STM32某个外设的数量及其对应的引脚
参考ST MCU 最新选型手册.pdf
|F103XX串口号|TXD|RXD|
|---|---|---|
|1|PA9|PA10|
|2|PA2|PA3|
|3|PB10|PB11|
|4|PC10|PC11|
|5|PC12|PD2|
参考STM32F103ZET6.pdf

串口数据接收过程：<br>
外部设备-》串行数据输入-》接收移位寄存器-》接收数据寄存器（RDR）-》数据寄存器（DR）-》CPU

串口数据发送过程：<br>
CPU-》数据寄存器（DR）-》发送数据寄存器（TDR）-》发送移位寄存器-》串行数据输出-》外部设备

#### 波特率
波特率计算公式 
$$baud = \frac{f_{ck}}{16*USARTDIV}$$ 
其中 $f_{ck}$ 是串口的时钟，如：USART1的时钟是PCLK2，其他串口都是PCLK1

波特比率寄存器：共32位，分别在[15:4]（DIV_Mantissa）[3:0]（DIV_Fraction）中写入USARTDIV的整数部分和小数部分

### HAL库外设初始化MSP回调机制
### HAL库中断回调机制
### USART/UART异步通信配置步骤
### IO引脚复用功能
### 实战项目